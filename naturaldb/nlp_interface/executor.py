"""
Function Executor - Executes function calls on QueryEngine
"""

from typing import Any, Dict, List, Optional, Callable
import json


class FunctionExecutor:
    """
    Executes function calls generated by NLQueryProcessor on a QueryEngine instance.
    """
    
    def __init__(
        self,
        query_engine: Any,
        confirmation_callback: Optional[Callable[[str, Dict[str, Any]], bool]] = None
    ):
        """
        Initialize the function executor.
        
        Args:
            query_engine: QueryEngine instance to execute operations on
            confirmation_callback: Optional callback for confirming sensitive operations
                                  Should accept (operation_name, arguments) and return bool
        """
        self.query_engine = query_engine
        self.confirmation_callback = confirmation_callback
        
        # Import here to avoid circular dependency
        from .tool_registry import DatabaseToolRegistry
        self.sensitive_operations = DatabaseToolRegistry.get_sensitive_operations()
    
    def execute(self, function_name: str, arguments: Dict[str, Any]) -> Any:
        """
        Execute a single function call.
        
        Args:
            function_name: Name of the function to call
            arguments: Dictionary of arguments to pass to the function
        
        Returns:
            Result of the function call
        
        Raises:
            ValueError: If operation requires confirmation and is not confirmed
            AttributeError: If function doesn't exist on QueryEngine
        """
        # Check if this is a sensitive operation
        if function_name in self.sensitive_operations:
            if self.confirmation_callback:
                confirmed = self.confirmation_callback(function_name, arguments)
                if not confirmed:
                    return {
                        "success": False,
                        "error": f"Operation '{function_name}' was not confirmed",
                        "message": "User did not confirm sensitive operation"
                    }
            else:
                # No confirmation callback - warn but allow
                print(f"⚠️  Warning: Executing sensitive operation '{function_name}' without confirmation")
        
        # Get the method from QueryEngine
        if not hasattr(self.query_engine, function_name):
            raise AttributeError(f"QueryEngine has no method '{function_name}'")
        
        method = getattr(self.query_engine, function_name)
        
        # Execute the method
        try:
            result = method(**arguments)
            
            # Serialize the result for JSON transmission
            return self._serialize_result(result)
        
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "function": function_name,
                "arguments": arguments
            }
    
    def execute_batch(self, function_calls: List[Dict[str, Any]]) -> List[Any]:
        """
        Execute multiple function calls in sequence.
        
        Args:
            function_calls: List of dictionaries with 'name' and 'arguments' keys
        
        Returns:
            List of results, one for each function call
        """
        results = []
        
        for call in function_calls:
            function_name = call.get('name')
            arguments = call.get('arguments', {})
            
            if not function_name:
                results.append({
                    "success": False,
                    "error": "Missing function name in call"
                })
                continue
            
            result = self.execute(function_name, arguments)
            results.append(result)
        
        return results
    
    def _serialize_result(self, result: Any) -> Any:
        """
        Serialize a result for JSON transmission.
        Handles Record objects, lists, and other NaturalDB types.
        
        Args:
            result: The result to serialize
        
        Returns:
            JSON-serializable version of the result
        """
        # Import here to avoid circular dependency
        from naturaldb.entities import Record, Table
        
        # Handle None
        if result is None:
            return {"success": True, "result": None}
        
        # Handle Record objects
        if isinstance(result, Record):
            return {
                "success": True,
                "result": {
                    "id": result.id,
                    "data": result.data
                }
            }
        
        # Handle list of Records
        if isinstance(result, list) and result and isinstance(result[0], Record):
            return {
                "success": True,
                "count": len(result),
                "results": [{"id": r.id, "data": r.data} for r in result]
            }
        
        # Handle Table objects
        if isinstance(result, Table):
            return {
                "success": True,
                "result": {
                    "name": result.name,
                    "indexes": result.indexes
                }
            }
        
        # Handle list of Tables
        if isinstance(result, list) and result and isinstance(result[0], Table):
            return {
                "success": True,
                "count": len(result),
                "tables": [t.name for t in result]
            }
        
        # Handle dictionaries (e.g., aggregation results)
        if isinstance(result, dict):
            return {
                "success": True,
                "result": result
            }
        
        # Handle lists
        if isinstance(result, list):
            return {
                "success": True,
                "count": len(result),
                "results": result
            }
        
        # Handle primitive types
        if isinstance(result, (str, int, float, bool)):
            return {
                "success": True,
                "result": result
            }
        
        # Fallback: try to convert to string
        try:
            return {
                "success": True,
                "result": str(result)
            }
        except Exception as e:
            return {
                "success": False,
                "error": f"Could not serialize result: {str(e)}"
            }
    
    @staticmethod
    def create_simple_confirmation() -> Callable[[str, Dict[str, Any]], bool]:
        """
        Create a simple console-based confirmation callback.
        
        Returns:
            Confirmation callback function
        """
        def confirm(operation: str, arguments: Dict[str, Any]) -> bool:
            print(f"\n⚠️  CONFIRMATION REQUIRED")
            print(f"Operation: {operation}")
            print(f"Arguments: {json.dumps(arguments, indent=2)}")
            response = input("Proceed? (yes/no): ").lower().strip()
            return response in ['yes', 'y']
        
        return confirm
